; ------------------------------------------------------------------------------------------------------------- ;
; VIC 1541 - DOS Routines - Entry Points
; ------------------------------------------------------------------------------------------------------------- ;
SETLDS                      = $c100                         ; turn on drive-active LED for current drive
LEDSON                      = $c118                         ; turn on drive-active LED for drive #0
ERROFF                      = $c123                         ; clear error flags / switch off error LED flashing
ERRON                       = $c12c                         ; switch on error LED flashing
PARSXQ                      = $c146                         ; parse & execute the string in the CMDBUF CMD input buffer
ENDCMD                      = $c194                         ; successful CMD termination
SCREND                      = $c1a3                         ; successful CMD termination 'OK' message
SCREN1                      = $c1ad                         ; CMD termination: flag drive inactive / clear CMD buffer / close internal channels
CLRCB                       = $c1bd                         ; clear the CMD buffer
CMDERR                      = $c1c8                         ; CMD level error handler
SIMPRS                      = $c1d1                         ; simple parser - scan CMD string for ":"
PRSCLN                      = $c1e5                         ; scan CMD string for 1st ":"
TAGCMD                      = $c1ee                         ; tag the CMD string for CMDs with comma separated parms
PARSE                       = $c268                         ; scan the CMD string for the char in .A
CMDSET                      = $c2b3                         ; init CMD tables and CMD pointers
CMDRST                      = $c2dc                         ; init (zero) all important variables and tables
ONEDRV                      = $c312                         ; set up file and drive num tables
ALLDRS                      = $c320                         ; set up all drives numbers from F2CNT
SETDRV                      = $c33c                         ; get drive number from CMD string or set default drive number to #0
SETANY                      = $c368                         ; set actual drive number from any configuration
TOGDRV                      = $c38f                         ; toggle drive number
FS1SET                      = $c398                         ; set and check file type
TST0V1                      = $c3bd                         ; test drive number in .A for '0' or '1'
OPTSCH                      = $c3ca                         ; determine optimal drive search for LOOKUP and FNDFIL 
LOOKUP                      = $c44f                         ; look up all files from the CMD string in DIR
FFRE                        = $c48b                         ; find file re-entry - find any next filename in DIR
FFST                        = $c49d                         ; find file start entry - find 1st filename in DIR
FNDFIL                      = $c4b5                         ; find file continuous re-entry - find next matching filename
COMPAR                      = $c4d8                         ; compare all filenames in CMD string with each valid entry in DIR
CMPCHK                      = $c589                         ; check table for unfound files
SRCHST                      = $c5ac                         ; start DIR search - init all standard values
SRRE                        = $c604                         ; reenter DIR search - read DIR block from disk / start search entry
SEARCH                      = $c617                         ; continue SEARCH of entries - try search next valid file in DIR
AUTOI                       = $c63d                         ; check for disk in drive - INIT on disk change
TRNAME                      = $c66e                         ; transfer filenames from input buffer to DIR buffer
TRCMBF                      = $c688                         ; transfer CMD buffer to any other buffer
FNDLMT                      = $c6a6                         ; find the end of CMD string in CMDBUF
GETNAM                      = $c6ce                         ; get a file entry from DIR
GNSUB                       = $c6de                         ; create a DIR listing line from a file entry
BLKNB                       = $c7ac                         ; fill DIR listing line buffer with blanks
NEWDIR                      = $c7b7                         ; start a new DIR listing - create DIR listing header
MSGFRE                      = $c806                         ; end the DIR listing - create 'BLOCKS FREE.' last line
SCRTCH                      = $c823                         ; command: S = SCRATCH
DELFIL                      = $c87d                         ; delete a file by it's file links - free blocks in BAM
DELDIR                      = $c8b6                         ; delete a DIR entry
DUPLCT                      = $c8c1                         ; command: D = DUPLICATE (not available on the 1541)
FORMAT                      = $c8c6                         ; format a disk handler
DSKCPY                      = $c8f0                         ; command: C = COPY
PUPS1                       = $c932                         ; set up parameters to copy a whole disk (not used)
COPY                        = $c952                         ; copy file(s) to one file
CY                          = $c9a7                         ; copy a file
OPIRFL                      = $c9fa                         ; open an internal READ channel to read a file
GIBYTE                      = $ca35                         ; get a byte from the internal READ channel
GCBYTE                      = $ca39                         ; get a byte from any READ channel
CYEXT                       = $ca53                         ; copy REL file records
RENAME                      = $ca88                         ; command: R = RENAME
CHKIN                       = $cacc                         ; check existence of current file
CHKIO                       = $cae7                         ; check NON existence of current file
MEM                         = $caf8                         ; command: M = MEMORY (WRE) handler
MEMEX                       = $cb1d                         ; command: memory-execute (M-E)
MEMRD                       = $cb20                         ; command: memory-read (M-R)
MEMERR                      = $cb4b                         ; error: bad memory command
MEMWRT                      = $cb50                         ; command: memory-write (M-W)
USER                        = $cb5c                         ; command: U = USER
USRINT                      = $cb63                         ; command: U0 - init pointers to user CMD JMP table
USER_US10                   = $cb6c                         ; entry point: execute 'Ux' code by command address table
USREXC                      = $cb72                         ; get user command address from table and exec user code
OPNBLK                      = $cb84                         ; command: open a direct access channel
BLOCK                       = $cc1b                         ; command: B = BLOCK (EPRWFA) handler
BLKPAR                      = $cc6f                         ; convert all CMD string parm values from ASCII to HEX
ASCHEX                      = $cca1                         ; convert one CMD string parm value from ASCII to HEX
BLKFRE                      = $ccf5                         ; command: B-F - BLOCK-FREE
BLKALC                      = $cd03                         ; command: B-A - BLOCK-ALLOCATE
BLKRD2                      = $cd36                         ; command: B-R subroutine - test parms / read a block from disk
GETSIM                      = $cd3c                         ; command: B-R subroutine - get a byte from buffer
BLKRD3                      = $cd42                         ; command: B-R subroutine - read a block from disk
BLKRD                       = $cd56                         ; command: B-R - BLOCK-READ
UBLKRD                      = $cd5f                         ; command: U1 - B-R (BLOCK-READ) replacement
BLKWT                       = $cd73                         ; command: B-W - BLOCK-WRITE
UBLKWT                      = $cd97                         ; command: U2 - B-W (BLOCK-WRITE) replacement
BLKEXC                      = $cda3                         ; command: B-E - BLOCK-EXECUTE
BLKPTR                      = $cdbd                         ; command: B-P - BLOCK-POINTER
BUFTST                      = $cdd2                         ; open a channel and allocate a buffer
BKOTST                      = $cdf2                         ; test BLOCK operation parameters
BLKTST                      = $cdf5                         ; set up DRVNUM/TRACK/SECTOR from CMD string values
FNDREL                      = $ce0e                         ; find a data block in a REL file
MULPLY                      = $ce2c                         ; calculate record position in bytes
DIV254                      = $ce6e                         ; divide ACCUM by 254
DIV120                      = $ce71                         ; divide ACCUM by 120
ZERRES                      = $ced9                         ; zero RESULT area
ACCX4                       = $cee2                         ; ACCUM * $04
ACCX2                       = $cee5                         ; ACCUM * $02
ADDRES                      = $ceed                         ; add ACCUM to RESULT: RESULT = RESULT + ACCUM[1,2,3]
LRUINT                      = $cefa                         ; init the LRU (least recently used) table
LRUUPD                      = $cf09                         ; update LRU (least recently used) table with LINDX
DBLBUF                      = $cf1e                         ; double buffer: switch the active and inactive buffers
DBSET                       = $cf7b                         ; set up double buffering
TGLBUF                      = $cf8c                         ; toggle a buffer from inactive to active
PIBYTE                      = $cf9b                         ; write a byte to a buffer via internal WRITE channel
PBYTE                       = $cfaf                         ; write a byte to a buffer via any channel
PUT                         = $cfb7                         ; main routine: write to a channel
PUTBYT                      = $cff1                         ; write DATA byte to buffer
INTDRV                      = $d005                         ; command: I = INITIALIZE
ITRIAL                      = $d00e                         ; init drive numbered in DRVNUM
INITDR                      = $d042                         ; init drive
NFCALC                      = $d075                         ; count number of free blocks in BAM
STRRD                       = $d09b                         ; start reading a block
STRDBL                      = $d0af                         ; start double buffering: read a block / read its subsequent block into a 2nd buffer
RDBUF                       = $d0c3                         ; entry point: start a read JOB of TRACK, SECTOR
WRTBUF                      = $d0c7                         ; entry point: start a write JOB of TRACK, SECTOR
STRTIT                      = $d0c9                         ; main routine: exec the selected JOB (READ/WRITE) of TRACK, SECTOR
FNDRCH                      = $d0eb                         ; test if channel in SA is open for READ
FNDWCH                      = $d107                         ; test if channel in SA is open for WRITE
TYPFIL                      = $d125                         ; get current file type - check for REL file type
GETPRE                      = $d12f                         ; get current buffer and channel number
GETBYT                      = $d137                         ; read one byte from the active buffer
RDBYT                       = $d156                         ; read a byte from file
WRTBYT                      = $d19d                         ; write a byte to the active channel
INCPTR                      = $d1c6                         ; increment pointer to the active buffer
SETDRN                      = $d1d3                         ; set JOB code drive number as current drive number
GETWCH                      = $d1df                         ; entry point: search a channel and its buffer for WRITE
GETRCH                      = $d1e2                         ; entry point: search a channel and its buffer for READ
GETR2                       = $d1e3                         ; main routine: search of a channel and its buffer for READ/WRITE
FRECHN                      = $d227                         ; free channel associated with secondary address in SA except CMD channel
RELBUF                      = $d25a                         ; release a buffer and its associated channel
GETBUF                      = $d28e                         ; search and get a free buffer
FNDBUF                      = $d2ba                         ; find a free buffer number and set used flag in BUFUSE
FREIAC                      = $d2da                         ; free the inactive buffer
FREBUF                      = $d2f3                         ; set flag buffer free in BUFUSE
CLRCHN                      = $d307                         ; free all channels except the CMD channel
CLDCHN                      = $d313                         ; close all channels for current drive except the CMD channel
STLBUF                      = $d339                         ; steal an inactive buffer
FNDLNX                      = $d37f                         ; find the next free channel to use
GBYTE                       = $d39b                         ; get the next byte from the internal READ channel
GET                         = $d3aa                         ; get the next byte from current channel
RNDGET                      = $d3de                         ; get a byte from a REL file
SEQGET                      = $d400                         ; get the next data byte
GETERC                      = $d414                         ; get a byte from ERROR channel
NXTBUF                      = $d44d                         ; read next block of a file following it's FILE_LINK
DRTRD                       = $d460                         ; entry point: direct block READ
DRTWRT                      = $d464                         ; entry point: direct block WRITE
DRT                         = $d466                         ; main routine: exec selected direct block READ/WRITE request
OPNIRD                      = $d475                         ; open an internal READ channel and READ a block from disk
OPNTYP                      = $d477                         ; open an internal channel for READ a block of any filetype
OPNIWR                      = $d486                         ; open an internal channel for WRITE a block
NXDRBK                      = $d48d                         ; allocate/write next DIR block on DIR TRACK 18
SETPNT                      = $d4c8                         ; set DIR/INPUT buffer pointers to current buffer plus offset in .A
FREICH                      = $d4da                         ; free both READ/WRITE internal channels
GETPNT                      = $d4e8                         ; get active buffer pointer and set DIR buffer pointer
SETDIR                      = $d4eb                         ; set DIR buffer pointer from any buffer
DRDBYT                      = $d4f6                         ; direct READ of a byte from current buffer
SETLJB                      = $d506                         ; set up JOB using last JOBs drive
SETJOB                      = $d50e                         ; set up new JOB and check TRACK/SECTOR
TSERR                       = $d54a                         ; error: illegal TRACK & SECTOR
HED2TS                      = $d552                         ; set TRACK and SECTOR values for the current JOB
TSCHK                       = $d55f                         ; check for legal TRACK/SECTOR numbers
VNERR                       = $d572                         ; error: DOS mismatch
SJB1                        = $d57a                         ; finish JOB setup
DOREAD                      = $d586                         ; entry point: transmit READ to DC
DOWRIT                      = $d58a                         ; entry point: transmit WRITE to DC
DOJOB                       = $d58c                         ; main routine: exec selected READ/WRITE
DOIT                        = $d590                         ; transmit JOB code
DOIT2                       = $d593                         ; handover JOB code to DC
WATJOB                      = $d599                         ; wait for End of JOB
TSTJOB                      = $d5a6                         ; test if JOB has executed successfully
RECOV                       = $d5c6                         ; recover from errors - redo JOB/BUMP
HEDOFF                      = $d676                         ; position the READ/WRITE head relatively to its current position
MOVHED                      = $d693                         ; move the READ/WRITE head one TRACK in/outwards
DOREC                       = $d6a6                         ; JOB recovery handler in case of errore
SETHDR                      = $d6d0                         ; set the active buffers header to TRACK/SECTOR/ID
SETH                        = $d6d3                         ; set any buffers header to TRACK/SECTOR/ID
ADDFIL                      = $d6e4                         ; add a new filename to the DIR
OPEN                        = $d7b4                         ; OPEN a channel from the serial bus
OPREAD                      = $d9a0                         ; open a file to READ
OPWRIT                      = $d9e3                         ; open a file to WRITE and add it to DIR
OPFIN                       = $d9ef                         ; open a file finish
CKTM                        = $da09                         ; check and set file MODE and TYPE
APPEND                      = $da2a                         ; prepare a file for APPEND
LOADIR                      = $da55                         ; load the DIR
CLOSE                       = $dac0                         ; close the file related to the current SA
CLSALL                      = $daec                         ; close all files (if CMD channel shall be closed)
CLSCHN                      = $db02                         ; locate and close a file of current SA
CLSREL                      = $db2c                         ; close a REL file
CLSWRT                      = $db62                         ; close a WRITE file
CLSDIR                      = $dba5                         ; close (actualize) DIR after a WRITE file
OPNRCH                      = $dc46                         ; open a READ channel with two buffers and read a block
INITP                       = $dcb6                         ; initialize variables for open channel
OPNWCH                      = $dcda                         ; open WRITE channel with two buffers and create block
PUTSS                       = $dd8d                         ; write a byte into SS
SCFLG                       = $dd95                         ; set or clear file type flags
SETFLG                      = $dd97                         ; set file type flags
CLRFLG                      = $dd9d                         ; clear file type flags
TSTFLG                      = $dda6                         ; test file type flags
TSTWRT                      = $ddab                         ; test JOB code for WRITE
TSTCHN                      = $ddb7                         ; test for active files in LINTAB table
SCRUB                       = $ddf1                         ; write out buffer if 'dirty' - buffer has changed
SETLNK                      = $ddfd                         ; write next SECTOR into buffer (header) from TRACK/SECTOR
GETLNK                      = $de0c                         ; get TRACK/SECTOR from file link in buffer
NULLNK                      = $de19                         ; write link for last block into buffer (TRACK=$00)
SET00                       = $de2b                         ; init pointer to start of current (active) buffer
CURBLK                      = $de3b                         ; set TRACK/SECTOR from JOBS TRACK/SECTOR area - check SA for READ first
GETHDR                      = $de3e                         ; set TRACK/SECTOR from JOBS TRACK/SECTOR header
WRTAB                       = $de50                         ; entry point: init WRITE JOB in JOB queue for RDSS.SJ10
RDAB                        = $de57                         ; entry point: init READ JOB in JOB queue for RDSS.SJ10
WRTOUT                      = $de5e                         ; entry point: init WRITE JOB in JOB queue for RDSS.SJ20
RDIN                        = $de65                         ; entry point: init READ JOB in JOB queue RDSS.SJ20
WRTSS                       = $de6c                         ; entry point: init JOB WRITE SS block in JOB queue
RDSS                        = $de73                         ; entry point: init JOB READ SS block in JOB queue
RDLNK                       = $de95                         ; get TRACK/SECTOR from file link in active buffer
B0TOB0                      = $dea5                         ; transfer bytes from one buffer to another buffer
CLRBUF                      = $dec1                         ; clear a given buffer
SSSET                       = $ded2                         ; set SS pointer to start of SS buffer and return SS number
SSDIR                       = $dedc                         ; set active buffer pointer to current SS buffer
SETSSP                      = $dee9                         ; set active buffer pointer from current SS pointer
SSPOS                       = $def8                         ; set active buffer pointer from SSNUM and SSIND
IBRD                        = $df1b                         ; entry point: transfer READ JOBs to DC
IBWT                        = $df21                         ; entry point: transfer WRITE JOBs to DC
IBOP                        = $df25                         ; main routine: exec the selected READ/WRITE JOB
GSSPNT                      = $df45                         ; set SS buffer pointer
SCAL1                       = $df4c                         ; prepare to add max number of ptrs in SS
SSCALC                      = $df51                         ; calculate the amount of blocks needed for a REL file
SSTEST                      = $df66                         ; test the status of an SS block in buffer
GETACT                      = $df93                         ; get current (active) buffer number for current channel
GAFLGS                      = $df9e                         ; get and check active buffer number
GETINA                      = $dfb7                         ; get a channels inactive buffer number
PUTINA                      = $dfc2                         ; mark a channels current buffer as inactive
NXTREC                      = $dfd0                         ; create next record of a REL file
NRBUF                       = $e03c                         ; generate next record in buffer
RELPUT                      = $e07c                         ; write a REL data byte into record buffer
WRTREL                      = $e0ab                         ; write out REL records
CLREC                       = $e0f3                         ; clear the remainder of a REL record
SDIRTY                      = $e105                         ; set buffer 'dirty' flag
CDIRTY                      = $e115                         ; clear buffer 'dirty' flag
RDREL                       = $e120                         ; read a byte from a REL record in the record buffer
SETLST                      = $e16e                         ; set pointer to last character in REL file record
FNDLST                      = $e1b2                         ; find last byte .NE. $00 in a REL record
SSEND                       = $e1cb                         ; set SS and active buffer pointer to end of last record
BREAK                       = $e202                         ; error: illegal system TRACK or SECTOR
RECORD                      = $e207                         ; command: P = POSITION
POSITN                      = $e275                         ; position to REL record
POSBUF                      = $e29c                         ; fill buffers with the correct disk data blocks
BHERE                       = $e2d0                         ; test if block from JOBS TRACK/SECTOR header is in the active buffer
BHERE2                      = $e2d3                         ; test if block from TRACK/SECTOR is in the active buffer
NULBUF                      = $e2e2                         ; clear records in active buffer for extension
ADDNR                       = $e304                         ; test if next record still fits into current buffer
ADDREL                      = $e31c                         ; add a block to a REL file
ADDR1                       = $e33b                         ; add blocks to REL file and adapt the SS blocks
NEWSS                       = $e44e                         ; create a new SIDE SECTOR
ERROR                       = $e60a                         ; error handler after JOB execution
CMDER2                      = $e645                         ; command error: write error message into error bufffer
CMDER3                      = $e648                         ; command error
TLKERR                      = $e680                         ; error handler for TALK from bus
LSNERR                      = $e688                         ; error handler for LISTEN from bus
HEXDEC                      = $e69b                         ; convert HEX to BCD and write its ASCII value into ERROR msg buffer
BCDDEC                      = $e6ab                         ; convert BCD to ASCII and write its ASCII value into ERROR msg buffer
OKERR                       = $e6bc                         ; clear any errors and write OK message into error buffer
ERRTS0                      = $e6c1                         ; reset error TRACK/SECTOR and write OK message into error buffer
ERRMSG                      = $e6c7                         ; write error message into error bufffer
ERMOVE                      = $e706                         ; write error message from ERRTAB to ERRBUF
EADV1                       = $e767                         ; get lower case error message character - pre-increment error msg table pointer
EADV2                       = $e775                         ; get lower case error message character - post-increment error msg table pointer
BOOT                        = $e780                         ; AUTOBOOT routine
UTLODR                      = $e7a3                         ; command: & - Utility Loader Routine
GTABYT                      = $e839                         ; get a byte from the file open on the internal READ channel
ADDSUM                      = $e84b                         ; get a byte from the file open on the internal READ channel
ATNIRQ                      = $e853                         ; IRQ routine for serial bus
ATNSRV                      = $e85b                         ; ATN handler
TALK                        = $e909                         ; send data to the bus as a result of a TALK command from the c64
DATHI                       = $e99c                         ; set DATA OUT line to HI - release DATA line
DATLOW                      = $e9a5                         ; set DATA OUT line to LO - signal response
CLKLOW                      = $e9ae                         ; set CLOCK OUT line to LO
CLKHI                       = $e9b7                         ; set CLOCK OUT line HI
DEBNC                       = $e9c0                         ; debonce - wait for reply from bus
ACPTR                       = $e9c9                         ; get a data byte from the bus after a LISTEN command
LISTEN                      = $ea2e                         ; main listen routine
ILERR                       = $ea4e                         ; release all bus lines and go to idle loop
ATNLOW                      = $ea56                         ; call the ATN handler - service an ATN request
TSTATN                      = $ea59                         ; test if in ATN mode
PEZRO                       = $ea6e                         ; entry point: self test
PERR                        = $ea71                         ; entry point: handle hardware defects
DSKINT                      = $eaa0                         ; reset the whole floppy station
DIAGOK                      = $eb22                         ; floppy warm start - short floppy RESET routine
INTTAB                      = $eb4b                         ; initialize buffer pointer table
IDLE                        = $ebe7                         ; idle loop: waiting for something to do
STDIR                       = $ec9e                         ; load and prepare the DIR
MOVBUF                      = $ed59                         ; transfer a NAMBUF entry to DIR listing buffer
GETDIR                      = $ed67                         ; get a char for load of DIR
VERDIR                      = $ed84                         ; command: V = VALIDATE
VMKBAM                      = $ede5                         ; alloc BAM blocks with file SECTORs from DIR_LINK
NEW                         = $ee0d                         ; command: N = NEW - initialize a disk
NEWMAP                      = $eeb7                         ; create new BAM in buffer
MAPOUT                      = $eef4                         ; write new BAM to active JOBs drive if 'dirty'
SCRBAM                      = $eeff                         ; write new BAM to current drive if 'dirty'
SETBPT                      = $ef3a                         ; set BAM bitmap pointer BMPNT
NUMFRE                      = $ef4d                         ; fill NBTEMP with the number of free blocks on current drive
WFREE                       = $ef5c                         ; mark a block in TRACK/SECTOR as free in BAM - write BAM if 'dirty'
FRETS                       = $ef5f                         ; mark a block in TRACK/SECTOR as free in BAM
DTYBAM                      = $ef88                         ; set BAM 'dirty' flag
WUSED                       = $ef90                         ; mark a block in TRACK/SECTOR as used in BAM - write BAM if 'dirty'
USEDTS                      = $ef93                         ; mark a block in TRACK/SECTOR as used in BAM
FREUSE                      = $efcf                         ; create BAM image buffer and get image bit status of SECTOR
BAMBIT                      = $efd5                         ; get image bit status of SECTOR
WRTBM                       = $eff1                         ; write BAM to disk if 'dirty'
CLRBAM                      = $f005                         ; clear the BAM buffer
SETBAM                      = $f011                         ; create BAM image in BAM image buffer
SWAP                        = $f05b                         ; swap BAM images in buffer
PUTBAM                      = $f0a5                         ; put BAM image byte to its correct position in buffer
CLNBAM                      = $f0d1                         ; zero (clear) BAM TRACK/SECTOR numbers for current drive
REDBAM                      = $f0df                         ; read in BAM from disk if not present
BAM2A                       = $f10f                         ; load .A with channel number for BAM access
BAM2X                       = $f119                         ; load .X with channel number for BAM access
NXTTS                       = $f11e                         ; search next avaialable TRACK/SECTOR startimg from JOB header
NXTDS                       = $f12d                         ; search next avaialable TRACK/SECTOR from current TRACK/SECTOR
FNDNXT                      = $f173                         ; find the best available SECTOR of current TRACK
INTTS                       = $f1a9                         ; find the best available initial SECTOR of current TRACK
DERR                        = $f1f5                         ; error: directory error
GETSEC                      = $f1fa                         ; create BAM in buffer and find next free SECTOR starting at SECTOR
AVCK                        = $f220                         ; validity check of the block counts in BAM - check 'BLOCKS FREE' value
MAXSEC                      = $f24b                         ; get SECTOR maximum for given TRACK
KILLP                       = $f258                         ; kill protection: not implemented on the 1541
CNTINT                      = $f259                         ; initialize the DC registers
LCC                         = $f2b0                         ; main controller loop
TOP                         = $f2be                         ; top of loop to scan JOB queue
QUE                         = $f2f9                         ; set drive status to stepping
GOTU                        = $f33c                         ; calculate the disk density zone (1-4) of the desired TRACK
BMP                         = $f37c                         ; exec a BUMP to TRACK #1
SETJB                       = $f393                         ; set buffer address and buffer pointer for JOB
SEAK                        = $f3b1                         ; search for a valid header block on this TRACK
DONE                        = $f418                         ; exit no error in operation
BADID                       = $f41b                         ; exit error: '29, DISK ID MISMATCH'
CSERR                       = $f41e                         ; exit error: '27, READ ERROR' - checksum error in header
WSECT                       = $f423                         ; seek the next best SECTOR to service
CNVBIN                      = $f497                         ; convert HEADER bytes read from GCR to BIN
REED                        = $f4ca                         ; start check JOB code - READ JOB: seek and read/decode the block specified in HEADER
DSTRT                       = $f50a                         ; seek a specified block HEADER and wait for SYNC
SRCH                        = $f510                         ; search a block with a specific HEADER
SYNC                        = $f556                         ; wait for a disk SYNC signal
WRIGHT                      = $f56e                         ; continue check JOB code - WRITE JOB: write out a block from current data buffer to disk
CHKBLK                      = $f5e9                         ; build the CHECKSUM for the current data block
WTOBIN                      = $f5f2                         ; convert data buffer/overflow buffer from GCR to BIN
VRFY                        = $f691                         ; continue check JOB code - VERIFY JOB: verify data block
SECTSK                      = $f6ca                         ; continue check JOB code - SEEK JOB: seek a SECTOR
PUT4BG                      = $f6d0                         ; conversion of 4 BIN bytes to 5 GCR encoded bytes into a given buffer
BINGCR                      = $f78f                         ; BIN to GCR conversion
GET4GB                      = $f7e6                         ; conversion of 5 GCR coded bytes to 4 BIN bytes into a given buffer
GCRBIN                      = $f8e0                         ; convert the GCR encoded bytes of the buffer and overflow buffer into 256 BIN bytes
CONHDR                      = $f934                         ; convert HEADER data from BIN to GCR
ERRR                        = $f969                         ; disk controller error handler
TURNON                      = $f97e                         ; turn ON drive motor
TRNOFF                      = $f98f                         ; turn OFF drive motor
END                         = $f99c                         ; disk drive motor and head stepper control handler
INACT                       = $fa05                         ; head stepping handler
DOSTEP                      = $fa2e                         ; head step move in or out
STPOUT                      = $fa32                         ; prepare step head out
SHORT                       = $fa3b                         ; short stepper mode
SETLE                       = $fa4e                         ; end of stepper mode
STPIN                       = $fa63                         ; prepare step head in
STP                         = $fa69                         ; set the requested head stepping phase
SSACL                       = $fa7b                         ; accelerate head for fast step mode
SSRUN                       = $fa97                         ; fast stepping mode handler (RUN mode)
SSDEC                       = $faa5                         ; decelerate head
END33                       = $fabe                         ; terminate the motor and stepper control routine
FORMT                       = $fac7                         ; terminate the stepper control handler and exit to SYSIRQ
TOPP                        = $fb0c                         ; FORMAT a disk - controlled in FORMAT a disk handler routine
FWAIT                       = $fb39                         ; FORMAT: loop to wait for start of SYNC zone
COUNT                       = $fbb6                         ; FORMAT: count number of bytes in NON-SYNC segment
DS08                        = $fbe0                         ; FORMAT: calculate the total number of bytes needed to be recorded on this TRACK
CRTDAT                      = $fc86                         ; FORMAT: create a data block of zero bytes
WRTSYN                      = $fcb1                         ; FORMAT: write SYNC to disk
COMP                        = $fd2c                         ; FORMAT: verify FORMAT
TSTDAT                      = $fd62                         ; FORMAT: check the data block
FMTEND                      = $fd96                         ; FORMAT: end of FORMAT
SYNCLR                      = $fda3                         ; FORMAT: erase TRACK with SYNC ($28 * $ff = 10240 $FF-Bytes)
WRTNUM                      = $fdc3                         ; FORMAT: write out NUM SYNC bytes
FMTERR                      = $fdd3                         ; FORMAT: error handler
MOVUP                       = $fde5                         ; FORMAT: move the 1st 69 ($45) bytes in BUFF0 up to free space for BUFGCR bytes
MOVOVR                      = $fdf5                         ; FORMAT: move 69 ($45) bytes from overflow buffer into the bottom of the data buffer
KILL                        = $fe00                         ; FORMAT: switch DC from WRITE mode to READ mode
CLEAR                       = $fe0e                         ; FORMAT: erase TRACK with DATA ($28 * $ff = 10240 $55-Bytes)
FBTOG                       = $fe30                         ; FORMAT: convert the block HEADER bytes from BIN to GCR
SYSIRQ                      = $fe67                         ; main system IRQ
SYSNMI                      = $fee7                         ; indirect for NMI to DIAGOK ($eb22) - floppy warm start
PEA7A                       = $feea                         ; patch: power on errors
SLOWD                       = $fef3                         ; patch: 1541 disk with slow serial receive for 1541 disk with slow serial receive
CLKDAT                      = $fefb                         ; patch: new CLOCK OUT LO and DATA OUT HI for 1541 disk with slow serial receive
NNMI                        = $ff01                         ; patch: new NMI routine entered from U9 UI user CMD
PEAA4                       = $ff10                         ; patch: set VIA's (patch5 for v5)
PE9DF                       = $ff20                         ; patch: listen to serial bus
; --------------------------------------------------------------------------------------------------------------------- ;
; 1541 - DOS Tables
; --------------------------------------------------------------------------------------------------------------------- ;
DRVTYP                      = $c000                         ; drive typy ID
FREEC0                      = $c001                         ; code patch area 01
SCHTBL                      = $c440                         ; drive access byte table
DECTAB                      = $ccf2                         ; decimal conversion
ERRTAB                      = $e4fc                         ; ASCII code of all DOS error messages
BMASK                       = $efe9                         ; BAM image SECTOR bit masks
BGTAB                       = $f77f                         ; conversion bytes BIN to GCR
GCRHI                       = $f8a0                         ; conversion GCR to BIN - HI nybble
GCRLO                       = $f8c0                         ; conversion GCR to BIN - LO nybble
DIRTRK                      = $fe85                         ; TRACK number BAM/DIR
BAMSIZ                      = $fe86                         ; BAM TRACK image length
MAPOFF                      = $fe87                         ; offset start TRACK images in BAM SECTOR (18,0)
DSKNAM                      = $fe88                         ; offset start disk name in BAM SECTOR (18,0)
CMDTBL                      = $fe89                         ; command chars
CJUMP                       = $fe95                         ; addresses of command routines
STRUCT                      = $fea5                         ; check for standard CMD syntax - but only for COPY/RENAME/SCRATCH/NEW
MODLST                      = $feb2                         ; file modes (READ, WRITE, APPEND, MODIFY)
TPLST                       = $feb6                         ; file types (DEL, SEQ, PRG, USR, REL)
TYPLST                      = $febb                         ; file type name in directory
LEDMSK                      = $feca                         ; drive LED mask bytes
ER00                        = $fecc                         ; value for error messages with BIT commands
NUMSEC                      = $fed1                         ; max number of SECTORs per TRACK
VERNUM                      = $fed5                         ; "A" - format type of the DOS-Version
NZONES                      = $fed6                         ; number of density zones
MAXTRK                      = $fed7                         ; TRACK numbers where a zone change occurs
OFFSET                      = $fedb                         ; control bytes for head misalignment at read problems
BUFIND                      = $fee0                         ; HI bytes buffer addresses
ECHKSM                      = $fee6                         ; checksum this ROM Version
FREEC1                      = $ff2f                         ; code patch area 02
SYSJMP                      = $ffe6                         ; system jump vectors
UBLOCK                      = $ffea                         ; adresses user commands
; --------------------------------------------------------------------------------------------------------------------- ;
