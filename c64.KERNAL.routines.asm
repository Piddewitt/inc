; ------------------------------------------------------------------------------------------------------------- ;
; C64 - KERNAL ROM ($e000 - $ffff)
; ------------------------------------------------------------------------------------------------------------- ;
                            .weak   ; avoid error: duplicate definition
; --------------------------------------------------------------------------------------------------------------------- ;
; Any symbols defined inside can be overridden by “stronger” symbols in the same scope from outside
; --------------------------------------------------------------------------------------------------------------------- ;
; KERNAL - messages
; --------------------------------------------------------------------------------------------------------------------- ;
MSIO                        = $f0bd ; KERNAL I/O error messages
MSCTRL                      = $f0c9 ; KERNAL control messages
CHKE0                       = $e45f ; BASIC BYTES FREE
FREMES                      = $e473 ; **** COMMODORE 64 BASIC V2 ****" / " 64K RAM SYSTEM  
NODEV                       = $edad ; DEVICE NOT PRESENT
FRMERR                      = $edb0 ; READ/WRITE TIMEOUT
TBLA0R                      = $fd10 ; CBM80
; --------------------------------------------------------------------------------------------------------------------- ;
; KERNAL - Constants
; --------------------------------------------------------------------------------------------------------------------- ;
RMULZC                      = $e08d ; Float numbers for RND
RADDZC                      = $e092 ; Float numbers for RND
PI2                         = $e2e0 ; Float numbers for SIN, COS and TAN - PI/2
TWOPI                       = $e2e5 ; Float numbers for SIN, COS and TAN - PI*2
FR4                         = $e2ea ; Float numbers for SIN, COS and TAN - 1/4
SINCON                      = $e2ef ; Polynomial table - float numbers for SIN
ATNCON                      = $e33e ; Polynomial table - float numbers for ATN
RNDSED                      = $e3ba ; Initial random seed number for [RNDX]
BVTRS                       = $e447 ; BASIC vectors copied to RAM from $0300 onwards
BAUDOP                      = $e4ec ; PAL standard baud values
COLTAB                      = $e8da ; Colour codes
KEYCOD                      = $eb79 ; Addresses of keyboard decoding tables
MODE1                       = $eb81 ; Standard keytab
MODE2                       = $ebc2 ; With shift
MODE3                       = $ec03 ; With c= (commodore key)
CONTRL                      = $ec78 ; With ctrl
TVIC                        = $ecb9 ; VIC2 init values
RUNTB                       = $ece7 ; Keyboard buffer for auto load/run
LDTB2                       = $ecf0 ; Low bytes screen line addresses
VECTSS                      = $fd30 ; KERNAL indirect vector addresses
BSIT                        = $fd9b ; Indirects for tape IRQ's
BAUDO                       = $fec2 ; NTSC standard baud rate
KERVID                      = $ff80 ; KERNAL version identifier
VECTSH                      = $fffa ; SYSTEM hardware vectors
; --------------------------------------------------------------------------------------------------------------------- ;
STOLD                       = $e000 ; Continue BASIC function EXP()
POLYX                       = $e043 ; Polynomial evaluator - compute odd degrees for SIN and ATN
POLY                        = $e059 ; Compute polynomials according to table indexed by AY
RND                         = $e097 ; BASIC function RND()
QSETNR                      = $e0be ; Gget next number in RND() sequence
RND1                        = $e0d3 ; Copy byte swapped [FAC] into RND() seed
EREXIT                      = $e0f9 ; Handle BASIC I/O error
OUTCH                       = $e10c ; Output char to an available output channel with error check
INCHR                       = $e112 ; Input a byte from an available input channel with error check
COOUT                       = $e118 ; Open channel for output with error check
COIN                        = $e11e ; Open channel for input with error check
CGETL                       = $e124 ; Get char from input device with error check
CSYS                        = $e12a ; BASIC command SYS
CSYSRZ                      = $e147 ; BASIC command SYS return point - tail end of SYS code
CSAVE                       = $e156 ; BASIC command SAVE
CVERF                       = $e165 ; BASIC command VERIFY
CLOAD                       = $e168 ; BASIC command LOAD
COPEN                       = $e1be ; BASIC command OPEN
CCLOSE                      = $e1c7 ; BASIC command CLOSE
PLSV                        = $e1d4 ; Get parameters for LOAD/SAVE
PAOC                        = $e219 ; Get parameters for OPEN/CLOSE
COS                         = $e264 ; BASIC function COS()
SIN                         = $e26b ; BASIC function SIN()
TAN                         = $e2b4 ; BASIC function TAN()
ATN                         = $e30e ; BASIC function ATN()
BASSFT                      = $e37b ; BASIC warm start entry point
READY                       = $e386 ; Call ERROR/READY message - then warm start
NERROR                      = $e38b ; Handle ERROR/READY messages - then warm start
INIT                        = $e394 ; BASIC cold start entry point
INITAT                      = $e3a2 ; CHRGET subroutine for ZERO PAGE
INITCZ                      = $e3bf ; Init BASIC RAM locations
INITMS                      = $e422 ; Print the start up message and init memory pointers
INITV                       = $e453 ; init BASIC vectors
PPACH                       = $e4ad ; Open channel for output (patch)
PRTYP                       = $e4d3 ; Flag the RS-232 start bit and set the parity
CPATCH                      = $e4da ; Save the current colour to the colour RAM (patch)
FPATCH                      = $e4e0 ; Pause after finding tape file - wait ~8.5 seconds for any key from the STOP key column
CLSR                        = $e544 ; Clear screen
NXTD                        = $e566 ; Set cursor HOME
STUPT                       = $e56c ; Set screen pointers for cursor row and col (move cursor to [TBLX] [PNTR])
VPAN                        = $e59a ; Call PANIC NMI entry
PANIC                       = $e5a0 ; Set SCREEN output and KEYBOARD input / Init the VIC chip
LP2                         = $e5b4 ; Retrieve char from start of the KEYBOARD buffer
LOOP4                       = $e5ca ; Output a char and wait for key
LOOP3                       = $e5cd ; Get chars from the KEYBOARD buffer until <RETURN> is detected
LOOP5                       = $e632 ; Get a char from SCREEN or KEYBOARD until <RETURN>
QTSWC                       = $e684 ; If open <QUOTE> detected toggle cursor <QUOTE> FLAG
NXT33                       = $e691 ; Print uppercase/graphic/reversed char
WLOGIC                      = $e6b6 ; Advance the cursor / init next line if necessary
BKLN                        = $e701 ; Move cursor back onto the previous line if possible
PRT                         = $e716 ; Print routine - output a char to screen
NJT0                        = $e72a ; Print routine - output unshifted characters
NXTX                        = $e7d4 ; Print routine - output shifted characters
NXLN                        = $e87c ; Init a NEWLINE and advance cursor to next SCREEN line
NXT1                        = $e891 ; Handle <RETURN> key
CHKBAK                      = $e8a1 ; Dec SCREEN line pointer if cursor moves left to new line
CHKDWN                      = $e8b3 ; Inc SCREEN line pointer if cursor moves right to new line
CHKCOL                      = $e8cb ; Set the colour code
SCROL                       = $e8ea ; Scroll SCREEN
NEWLIN                      = $e965 ; Insert a blank line on the SCREEN at the 1st noncontinued line following the cursor location
SCRLIN                      = $e9c8 ; Move SCREEN line from [SAL] to [PNT] and colors from [EAL] to [USER]
TOFROM                      = $e9e0 ; Set color memory pointers for moving line
SETPNT                      = $e9f0 ; Set up the start of SCREEN line address the cursor is on
CLRLN                       = $e9ff ; Clear the SCREEN line the cursor is on
DSPP                        = $ea13 ; Print char in .A and colour in .X on SCREEN
DSPP2                       = $ea1c ; print char in .A and colour in .X on SCREEN at cursor position
SCOLOR                      = $ea24 ; Calculate COLOUR RAM pointer
KEY                         = $ea31 ; Main IRQ entry point
KEYRTI                      = $ea7e ; Main IRQ exit point - clear interupt flags/Restore registers/RTI
REKEY                       = $eae0 ; Continue key decoding after evaluation of <SHIFT>/<CTRL>/<C=>
SHFLOG                      = $eb48 ; Toggle GFX/Lower case via the the <SHIFT>/<CTRL>/<C=> keys
KEYLG2                      = $eb64 ; Set keyboard decode table pointer
LOWER                       = $ec44 ; C☺heck for special char codes: <SWITCH TO LOWER CASE>
UPPER                       = $ec4f ; C☺heck for special char codes: <SWITCH TO UPPER CASE>/<SHIFT><C=>
LIST1                       = $ed11 ; Send a buffered control char
ISOURA                      = $ed36 ; Set serial clock LO / data HI / wait 1ms
ISOUR                       = $ed40 ; Send command or data byte in [BSOUR] on serial bus
SCATN                       = $edbe ; Set serial bus ATN HI
TKATN                       = $edcc ; Wait for the serial bus end after send
DLABYE                      = $ee03 ; Release ATN CLOCK and DATA
DLADLH                      = $ee06 ; Set serial clock out HI (release clock line) and data out HI (ready for data)
CLKHI                       = $ee85 ; Set the serial clock out HI
CLKLO                       = $ee8e ; Set the serial clock out LO
DATAHI                      = $ee97 ; Set the serial data out HI
DATALO                      = $eea0 ; Set the serial data out LO - <EOI> accepted
DEBPIA                      = $eea9 ; Get status serial data in to .C and status clock in to .Z
W1MS                        = $eeb3 ; Delay 1ms
RSTRAB                      = $eebb ; RS-232TRANS: sending a byte on the RS-232 port
RST010                      = $eed7 ; RS-232TRANS: start byte transfer - calculate RS-232 parity bit
RSTBGN                      = $ef06 ; RS-232TRANS: start byte transfer - set up the system variables ready
DSRERR                      = $ef2e ; RS-232TRANS: error: no DSR (data set ready)
CTSERR                      = $ef31 ; RS-232TRANS: error: no CTS
OENABL                      = $ef3b ; RS-232TRANS: set VIA 2 ICR - turn off an enabled NMI
BITCNT                      = $ef4a ; RS-232TRANS: calculate number of bits to be sent
RSRCVR                      = $ef59 ; RS-232RCVR:  receive
RSR018                      = $ef6e ; RS-232RCVR:  have stop bit - store in buffer (end of word handler)
RSRABL                      = $ef7e ; RS-232RCVR:  enable to recieve a byte
RSRTRT                      = $ef90 ; RS-232RCVR:  process RS-232 byte - no RS-232 start bit received
RSR030                      = $ef97 ; RS-232RCVR:  put data in buffer - received a whole byte and add it to the buffer
RSR060                      = $efdb ; RS-232RCVR:  check for errors
CKO232                      = $efe1 ; RS-232RCVR:  open RS-232 channel for output
BSOBAD                      = $f014 ; RS-232RCVR:  send byte to the RS-232 buffer - output a char passed in T1 from BSOUT
BSO232                      = $f017 ; RS-232RCVR:  send RS-232 byte from char buffer [T1] to the RS-232 buffer
BSO100                      = $f028 ; RS-232RCVR:  setup for RS-232 transmit
CKI232                      = $f04d ; RS-232RCVR:  input a file over user port using RS-232
BSI232                      = $f086 ; RS-232RCVR:  get byte from RS-232 receive buffer
RSP232                      = $f0a4 ; RS-232RCVR:  wait for end of RS-232 transfer - check RS-232 bus idle
SPMSG                       = $f12b ; Display control I/O message if in direct mode
MSG                         = $f12f ; Display the KERNEL I/O message
NGETIN                      = $f13e ; KERNAL routine GETIN
GN232                       = $f14e ; RS-232: read a byte from the RS-232 buffer
NBASIN                      = $f157 ; BASIN: input char from channel
JTGET                       = $f199 ; Get a byte from the appropriate tape buffer
BN30                        = $f1ad ; Input from serial bus
BN50                        = $f1b8 ; Get a byte from RS-232 device
NBSOUT                      = $f1ca ; BSOUT: output char to channel determined by variable [DFLTO]
CASOUT                      = $f1dd ; Output the char to tape or RS-232 device
BO50                        = $f208 ; Output the char to the RS-232 device
NCHKIN                      = $f20e ; CHKIN: open channel for input
JX330                       = $f237 ; Define serial bus as standard input - TALKer
NCKOUT                      = $f250 ; CHKOUT: open channel for output
CK40                        = $f279 ; Define serial bus as standard output - LISTENer
NCLOSE                      = $f291 ; CLOSE: close a logical file
JX115                       = $f2c8 ; Close tape file
JX120                       = $f2ee ; Close a serial file
JX150                       = $f2f1 ; Remove a given logical file from table of logical primary and secondary addresses
LOOKUP                      = $f30f ; Find a file - lookup tablized logical file data
JLTLK                       = $f314 ; Find a file with logical file number in .A
JZ100                       = $f31f ; Set logical file number, device number, and secondary address from tables
NCLALL                      = $f32f ; CLALL: close all channels and files
NCLRCH                      = $f333 ; CLRCH: close input and output channels
NOPEN                       = $f34a ; OPEN: open a logical file
OP152                       = $f38b ; OPEN: open tape device
OPENI                       = $f3d5 ; Send OPEN LOAD or SAVE command to device on serial bus
OPN232                      = $f409 ; Open a RS-232 or parallel port file
CLN232                      = $f483 ; RS-232: clean up RS-232 system for open/close
NLOAD                       = $f4a5 ; LOAD RAM from from tape / RS-232 / serial bus devices $04-$1f
LD70                        = $f528 ; Send UNTALK and CLOSE command to serial bus                           
LD100                       = $f533 ; LOAD from tape
LUKING                      = $f5af ; Print message "SEARCHING FOR" <filename>
OUTFN                       = $f5c1 ; Print filename
LODING                      = $f5d2 ; Print "LOADING" or "VERIFYING"
NSAVE                       = $f5ed ; SAVE: save RAM to device
SV50                        = $f63f ; Send UNLISTEN and CLOSE command to serial bus
CLSEI                       = $f642 ; Close file on serial bus
SV102                       = $f65f ; Save RAM to TAPE device
SAVING                      = $f68f ; Print 'SAVING <filename>'
UD60                        = $f6bc ; Check <STOP> key
NSTOP                       = $f6ed ; STOP: check stop key flag
ERRMSG                      = $f6fb ; File ERROR message handler - print KERNAL "I/O ERROR #" <NUMBER> message
FAH                         = $f72c ; Find any tape header
TAPEH                       = $f76a ; Write a tape header
ZZZ                         = $f7d0 ; Return the tape buffer start pointer
LDAD1                       = $f7d7 ; Set the tape buffer start and end pointers
FAF                         = $f7ea ; Find a specific tape header
JTP20                       = $f80d ; Inc tape buffer index and check overflow
CSTE1                       = $f817 ; Wait for PLAY
CS10                        = $f82e ; Return tape sense
CSTE2                       = $f838 ; Check tape PLAY/RECORD
RBLK                        = $f841 ; Init a tape read - read header block entry
TRD                         = $f84a ; Read load block entry
WBLK                        = $f864 ; Write header block entry
TWRT                        = $f867 ; Write load block entry
TWRT2                       = $f86b ; Write load block entry with no cycle count set
TAPE                        = $f875 ; Tape read/write
TSTOP                       = $f8d0 ; Scan <STOP> key and flag abort if pressed
STOP3                       = $f8dc ; Clear saved IRQ address
STT1                        = $f8e2 ; Set up timeout watch for next dipole
; --------------------------------------------------------------------------------------------------------------------- ;
KREAD                       = $f92c ; Read tape bits                                                       .hbu002. 'K' added
; --------------------------------------------------------------------------------------------------------------------- ;
RAD2                        = $fa10 ; Longlong handler
RADJ                        = $fa60 ; Store char
RD15                        = $fa70 ; Byte handler of tape read
RD58                        = $fb08 ; Check bad table for re-try (2nd pass)
VPRTY                       = $fb72 ; Compute parity over load
RD300                       = $fb8e ; Restore starting address pointers [SAH] & [SAL]
NEWCH                       = $fb97 ; New tape byte setup (8 bits & parity)
WRITE                       = $fba6 ; Toggle write bit according to LSB in [OCHAR]
WRTW                        = $fbad ; Set write long
WRTX                        = $fbb1 ; Toggle PULSE - generate a PULSE output by inverting Bit3=Tap_Out
WRTL3                       = $fbc8 ; Flag block done and exit interrupt
WRTN                        = $fbcd ; Tape write IRQ routine
WRTZ                        = $fc6a ; Write tape leader IRQ routine
TNIF                        = $fc93 ; Clean up interrupts and restore PIA's
STKY                        = $fcb8 ; Reset vector
BSIV                        = $fcbd ; Set tape IRQ vectors
TNOF                        = $fcca ; Turn off tape motor
CMPSTE                      = $fcd1 ; Compare start and end load/save addresses
INCSAL                      = $fcdb ; Increment read/write address pointer
START                       = $fce2 ; RESET: system hardware reset start
A0INT                       = $fd02 ; Scan for autostart ROM at $8000
SIZE                        = $fd88 ; Set top of memory / bottom of memory / screen memory
IOKEYS                      = $fddd ; Enable interrupt timer A
UDST                        = $fe1c ; Update [STATUS] - insert an error number into serial status byte
GETTOP                      = $fe27 ; Read top of memory
SETTOP                      = $fe2d ; Set top of memory
GETBOT                      = $fe36 ; Read bottom of memory
SETBOT                      = $fe3c ; Set bottom of memory
NNMI                        = $fe47 ; NMI handler
TIMB                        = $fe66 ; BRK handler
NNMI20                      = $fe72 ; RS-232: NMI routine
PREND                       = $febc ; Exit NMI routine
T2NMI                       = $fed6 ; RS-232: NMI in  - Handle an RS-232 bit input
FLNMI                       = $ff07 ; RS-232: NMI out - Start Timer B / Enable Timer B interrupts
POPEN                       = $ff2e ; Patch: Open RS-232 for universal KERNAL
SIMIRQ                      = $ff43 ; Simulate an IRQ (for tape read)
PULS                        = $ff48 ; IRQ handler
PIOKEY                      = $ff6e ; Start the CIA1 timer
KERJTB                      = $ff81 ; KERNAL jump table
; --------------------------------------------------------------------------------------------------------------------- ;
; KERNAL jump table routines real addresses
; --------------------------------------------------------------------------------------------------------------------- ;
IOBASE                      = $e500 ; Return base address of the I/O devices
SCRORG                      = $e505 ; Return max number of rows and cols of SCREEN
PLOT                        = $e50a ; Put/get the cursor row and column
CINT                        = $e518 ; Init VIC II chip registers SCREEN and KEYBOARD
SCNKEY                      = $ea87 ; General KEYBOARD scan
TALK                        = $ed09 ; Command devices on the serial bus to TALK
LISTN                       = $ed0c ; Command devices on the serial bus to LISTEN
SECND                       = $edb9 ; Send secondary address after LISTEN
TKSA                        = $edc7 ; Send secondary address after TALK
CIOUT                       = $eddd ; Output a buffered byte to serial bus
UNTLK                       = $edef ; Command serial bus to UNTALK
UNLSN                       = $edfe ; Command serial bus to UNLISTEN
ACPTR                       = $ee13 ; Input a byte from serial bus
LOADSP                      = $f49e ; Call LOAD RAM from a device
SAVESP                      = $f5dd ; Call SAVE RAM to device
UDTIM                       = $f69b ; Inc real time clock and check the <STOP> key - called every 60th second
RDTIM                       = $f6dd ; Read the real time clock
SETTIM                      = $f6e4 ; Set the real time clock
RESTOR                      = $fd15 ; Restore default I/O vectors
VECTOR                      = $fd1a ; Set kernal indirect and vectors
RAMTAS                      = $fd50 ; Test RAM and find RAM end
IOINIT                      = $fda3 ; Init SID, CIA, IRQ
SETNAM                      = $fdf9 ; Set filename
SETLFS                      = $fe00 ; Set filename parameters (logical, first, secondary addresses)
READST                      = $fe07 ; Read I/O status word
SETMSG                      = $fe18 ; Control KERNAL messages
SETTMO                      = $fe21 ; Set serial bus timeout
MEMTOP                      = $fe25 ; Get/Set top of memory
MEMBOT                      = $fe34 ; GEt/set the bottom of memory
PCINT                       = $ff5b ; Patch: Init VIC II chip SCREEN KEYBOARD PAL/NTSC FLAG
; --------------------------------------------------------------------------------------------------------------------- ;
                            .endweak ; 
; --------------------------------------------------------------------------------------------------------------------- ;
